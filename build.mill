//| mill-version: 1.0.3-native

import mill._, scalalib._
import mill.util.VcsVersion
import mill.scalalib.publish.{PomSettings, License, VersionControl, Developer}
import mill.api.Task.{Source, Sources}

import mill.api.ModuleRef

import os._

object `package` extends ScalaModule with SonatypeCentralPublishModule {

  override def artifactName = "scalaisl"

  override def pomSettings = PomSettings(
    description = "*Experimental* Scala 3 bindings for ISL (Integer Set Library)",
    organization = "io.github.papychacal",
    url = "https://github.com/PapyChacal/ScalaISL",
    licenses = Seq(License.MIT),
    versionControl = VersionControl.github(owner = "papychacal", repo = "scalaisl"),
    // TODO ?
    developers = Seq(
      Developer(
        id="papychacal",
        name = "Emilien Bauer",
        url = "https://github.com/PapyChacal"
      )
    )
  )

  override def publishVersion: T[String] = VcsVersion.vcsState().format(untaggedSuffix = "-SNAPSHOT")
  
  override def scalaVersion = "3.6.4"

  override def mvnDeps = Seq(
    mvn"com.github.jnr:jnr-ffi:2.2.17"
  )

  def islDir = moduleDir / "isl"

  def islSources = Sources({
    val dir = islDir
    if(!os.exists(dir / "configure")) {
      if(os.proc("./autogen.sh")
        .call(cwd = dir, propagateEnv = true, stdout = os.Inherit, stderr = os.Inherit).exitCode != 0) {
        throw new Exception("Failed to run ISL's autogen")
      }
    }
    os.list(dir).filter(_.last != "interface")
   }*)

   def islExtractorSources = Source {
    islDir / "interface"
   }

  def numThreads = java.lang.Thread.activeCount()

  def compileISL = Task {
    islSources()
    val configure_path = (islDir / "configure").relativeTo(Task.dest)
    if(os.proc(configure_path, "--prefix", Task.dest / "install")
      .call(cwd = Task.dest, propagateEnv = true, stdout = os.Inherit, stderr = os.Inherit).exitCode != 0) {
      throw new Exception("Failed to configure ISL")
    }
    if(os.proc("make", s"-j$numThreads", "install").call(cwd = Task.dest, propagateEnv = true, stdout = os.Inherit, stderr = os.Inherit).exitCode != 0) {
      throw new Exception("Failed to build ISL")
    }

    PathRef(Task.dest)
  }
  
  def ISLLib = Task {
    os.list(compileISL().path / "install" / "lib").map(PathRef(_))
  }

  def compileISLExtractor = Task {
    compileISL()
    islExtractorSources()

    val resourceDirPath = Task.dest
    val configure_path = (islDir / "interface" / "configure").relativeTo(resourceDirPath)
    if(os.proc(configure_path)
      .call(cwd = resourceDirPath, propagateEnv = true, stdout = os.Inherit, stderr = os.Inherit).exitCode != 0) {
      throw new Exception("Failed to configure ISL extractor")
    }
    if(os.proc("make", s"-j$numThreads").call(cwd = resourceDirPath, propagateEnv = true, stdout = os.Inherit, stderr = os.Inherit).exitCode != 0) {
      throw new Exception("Failed to build ISL extractor")
    }

    Seq(
      PathRef(resourceDirPath / "extract_interface")
    )
  }

  override def generatedSources = Task {

    val ISLOutput = compileISL().path

    val extractor = compileISLExtractor()

    val generatedSourcePath = Task.dest / "islgen.scala"

    if(os.proc(extractor,"--language", "scala-3", (islDir / "all.h").relativeTo(Task.dest), "-I" + (islDir / "include").relativeTo(Task.dest), "-I" + (ISLOutput / "include").relativeTo(Task.dest)).call(cwd = Task.dest, stdout = generatedSourcePath, stderr = os.Inherit).exitCode != 0) {
      throw new Exception("Failed to extract ISL interface")
    }

    super.generatedSources() :+ PathRef(generatedSourcePath)
  }

  def resources = Task {
    super.resources() ++ ISLLib()
  }
}
